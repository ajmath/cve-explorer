package com.ajmath.cveexplorer;

import com.ajmath.cveexplorer.generated.AffectedPackage;
import com.ajmath.cveexplorer.generated.Cve;
import com.ajmath.cveexplorer.generated.Reference;
import com.ajmath.cveexplorer.generated.Severity;
import com.google.common.base.Joiner;
import com.google.common.collect.Lists;
import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import org.springframework.stereotype.Component;

import javax.annotation.PostConstruct;
import java.io.File;

import java.io.InputStream;
import java.io.InputStreamReader;
import java.lang.reflect.Type;
import java.net.URL;
import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.time.Instant;
import java.time.LocalDateTime;
import java.time.ZoneOffset;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.stream.Stream;
import java.util.zip.GZIPInputStream;

import static java.util.stream.Collectors.toList;

/**
 * This file is intentionally written to be sloppy to avoid spending an excessive amount of time on
 * describing the NVD JSON spec in POJOs. There are plenty of unsafe casts to go around in this file
 * and that's okay for this assignment as the data is hard-coded.
 *
 * I would not recommend shipping this without adding proper error handling and ideally wiring up the json
 * parsing with gson data binding
 */
@Component
public class CveDataStore {

  private static String RESOURCE_FOLDER = "cve-data";
  private static SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd'T'HH:mmX");

  private Gson gson = new Gson();
  private List<Cve> data = Lists.newLinkedList();


  @PostConstruct
  public void init() throws Exception {
    this.loadData();
  }

  public Stream<Cve> stream() {
    return this.data.stream();
  }

  private void loadData() throws Exception {
    data = getCveFiles().parallelStream()
      .map(this::loadCveFromPath)
      .flatMap(d -> d.stream())
      .sorted(Comparator.comparing(Cve::getPublishedOn).reversed())
      .collect(toList());
    System.out.println("Loaded " + data.size() + " vulnerabilities");
  }

  private List<Cve> loadCveFromPath(String cvePath) {
    try {
      InputStream stream = this.getClass().getResourceAsStream(cvePath);
      GZIPInputStream input = new GZIPInputStream(stream);
      List<Cve> items = loadCveFromFile(input);
      System.out.println(cvePath + ": " + items.size());
      return items;
    } catch (Exception e) {
      System.out.println("Error loading " + cvePath + "\n" + e.toString());
    }
    return Collections.emptyList();
  }

  private List<Cve> loadCveFromFile(GZIPInputStream input) throws ParseException {
    List<Cve> items = Lists.newLinkedList();
    Type type = new TypeToken<Map<String, Object>>(){}.getType();
    Map<String, Object> json = gson.fromJson(new InputStreamReader(input), type);
    for (Map<String, Object> jsonCveItem : (List<Map<String, Object>>) json.get("CVE_Items")) {
      Cve cve = parseCve(jsonCveItem);
      if (cve != null) {
        items.add(cve);
      }
    }
    return items;
  }

  private Cve parseCve(Map<String, Object> jsonCveItem) {
    String id = "?";
    try {
      Map<String, Object> jsonCve = (Map<String, Object>) jsonCveItem.get("cve");
      Map<String, String> meta = (Map<String, String>) jsonCve.get("CVE_data_meta");
      id = meta.get("ID");

      Map<String, List<Map<String, String>>> desc = (Map<String, List<Map<String, String>>>) jsonCve.get("description");
      Map<String, String> descData = desc.get("description_data").get(0);

      Cve cve = new Cve();
      cve.setId(id);
      if (descData != null) {
        cve.setDescription(descData.get("value"));
        if (cve.getDescription().contains("* REJECT *")) {
          return null;
        }
      }

      LocalDateTime ldt = LocalDateTime.parse(
        (String) jsonCveItem.get("publishedDate"),
        DateTimeFormatter.ofPattern("yyyy-MM-dd'T'HH:mmX")
      );
      cve.setPublishedOn(new Date(ldt.toInstant(ZoneOffset.UTC).toEpochMilli()));
      cve.setSeverity(parseSeverity(jsonCveItem));
      cve.setReferences(parseReferences(jsonCve));
      cve.setAffectedPackages(parseAffectedPackages(jsonCve));
      return cve;
    } catch (Exception e) {
      System.out.println("Error loading cve: " + id + " : " + e.toString());
      e.printStackTrace();
      return null;
    }
  }

  private Collection<AffectedPackage> parseAffectedPackages(Map<String, Object> jsonCve) {
    try {
      List<AffectedPackage> packages = Lists.newLinkedList();
      Map<String, Map<String, List<Map<String, Object>>>> affects = (Map<String, Map<String, List<Map<String, Object>>>>)jsonCve.get("affects");
      for(Map<String, Object> v : affects.get("vendor").get("vendor_data")) {
        final String vendorName = (String) v.get("vendor_name");
        Map<String, List<Map<String, Object>>> product = (Map<String, List<Map<String, Object>>>)v.get("product");
        for(Map<String, Object> pd : product.get("product_data")) {
          AffectedPackage pack = new AffectedPackage();
          pack.setVendor(vendorName);
          pack.setProduct((String)pd.get("product_name"));

          Map<String, List<Map<String, Object>>> version = (Map<String, List<Map<String, Object>>>)pd.get("version");
          pack.setVersions(version.get("version_data").stream()
            .map(vd -> (String)vd.get("version_value"))
            .collect(toList()));

          packages.add(pack);
        }
      }
      return packages;
    } catch (Exception e) {
      System.out.println("Error parsing affected packages");
      e.printStackTrace();
      return Collections.EMPTY_LIST;
    }
  }

  private Collection<Reference> parseReferences(Map<String, Object> jsonCve) {
    Map<String, List<Map<String, Object>>> ref = (Map<String, List<Map<String, Object>>>) jsonCve.get("references");
    if (ref == null || !ref.containsKey("reference_data")) {
      return Collections.EMPTY_LIST;
    }
    return ref.get("reference_data").stream().map(r -> {
      Reference reference = new Reference();
      reference.setName((String)r.get("name"));
      reference.setUrl((String)r.get("url"));
      reference.setTags((List<String>)r.get("tags"));
      return reference;
    }).collect(toList());
  }

  private Severity parseSeverity(Map<String, Object> jsonCveItem) {
    Map<String, Object> impact = (Map<String, Object>) jsonCveItem.get("impact");
    if (impact == null || impact.keySet().size() == 0) {
      return null;
    }
    Map<String, Object> baseMetricV2 = (Map<String, Object>) impact.get("baseMetricV2");
    String sev = (String) baseMetricV2.get("severity");
    return Severity.valueOf(sev);
  }

  private List<String> getCveFiles() {
    ClassLoader loader = Thread.currentThread().getContextClassLoader();
    URL url = loader.getResource(RESOURCE_FOLDER);
    String path = url.getPath();
    return Arrays.stream(new File(path).listFiles())
      .map(f -> "/" + RESOURCE_FOLDER + "/" + f.getName())
      .collect(toList());
  }
}
